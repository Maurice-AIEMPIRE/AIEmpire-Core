{"id": "ki_1770772593489", "type": "fix", "title": "gemini_client.py env var crash", "content": "gemini_client.py darf NIEMALS os.getenv() direkt aufrufen. Alle Config MUSS durch antigravity.config importiert werden, weil config.py die .env Datei automatisch laedt. Direktes os.getenv() fuehrt nach Crash zu leeren Werten -> HTTP 400 'Invalid project resource name projects/'", "tags": ["bugfix", "config", "gemini", "crash", "critical"], "source": "crash-repair-2025", "confidence": 1.0, "references": ["antigravity/gemini_client.py", "antigravity/config.py"], "created_at": "2026-02-11T01:16:33.489191"}
{"id": "ki_1770772593490", "type": "pattern", "title": "Atomic Writes fuer crash-sichere Dateien", "content": "Jeder Datei-Write der kritisch ist (State, Config, JSON) MUSS als Atomic Write implementiert werden: 1) Schreibe in .tmp Datei, 2) os.rename() zum Ziel. os.rename() ist atomar auf POSIX. Kein Datenverlust bei Crash.", "tags": ["pattern", "crash-safety", "atomic-write"], "source": "crash-repair-2025", "confidence": 1.0, "references": ["antigravity/sync_engine.py"], "created_at": "2026-02-11T01:16:33.490278"}
{"id": "ki_1770772593491", "type": "architecture", "title": "Cross-Agent Verification Prinzip", "content": "Ein Agent darf NIEMALS seine eigene Arbeit bewerten. Verifikation muss immer durch einen ANDEREN Agent mit FRISCHEM Kontext erfolgen. Der Verifier sieht nur Aufgabe und Output, nicht den Prozess. Basiert auf Ryan Carson's Prinzip.", "tags": ["architecture", "verification", "quality", "agents"], "source": "twitter-ryan-carson", "confidence": 1.0, "references": ["antigravity/cross_verify.py"], "created_at": "2026-02-11T01:16:33.491160"}
{"id": "ki_1770772593492", "type": "architecture", "title": "Resource Guard Predictive Throttling", "content": "Reaktives Monitoring reicht NICHT. Resource Guard muss 1) Preemptive Checks vor Model-Start (can_launch), 2) Trend-basierte Vorhersage (steigt CPU/RAM?), 3) Signal Handling (SIGTERM/SIGINT sauberes Shutdown), 4) Crash Detection beim Start (Safe Mode). Ollama Models automatisch stoppen bei RAM-Krise.", "tags": ["architecture", "resource-management", "crash-prevention"], "source": "crash-repair-2025", "confidence": 1.0, "references": ["workflow_system/resource_guard.py"], "created_at": "2026-02-11T01:16:33.492045"}
{"id": "ki_1770772593493", "type": "learning", "title": "Model Routing Strategie", "content": "Ollama (lokal, kostenlos) fuer 95% der Tasks. Kimi K2.5 fuer komplexe Tasks (4%). Claude nur fuer kritische Entscheidungen (1%). NIEMALS ein grosses Model starten ohne vorher can_launch() vom Resource Guard abzufragen.", "tags": ["cost", "routing", "models", "optimization"], "source": "system-design", "confidence": 1.0, "references": [], "created_at": "2026-02-11T01:16:33.493078"}
{"id": "ki_1770772593493", "type": "pattern", "title": "Planning Mode Workflow", "content": "Inspiriert von Google Antigravity: RESEARCH -> PLAN -> APPROVE -> EXECUTE -> VERIFY. Kein Code ohne Plan. Kein Execute ohne Approval. Changes klassifiziert als [NEW], [MODIFY], [DELETE], [CONFIG]. Implementation Plan als Markdown vor jeder Aenderung.", "tags": ["workflow", "planning", "antigravity", "best-practice"], "source": "google-antigravity", "confidence": 1.0, "references": ["antigravity/planning_mode.py"], "created_at": "2026-02-11T01:16:33.493990"}
{"id": "ki_1770772593494", "type": "test", "title": "Test Knowledge", "content": "This is a test item", "tags": ["test"], "source": "pytest", "confidence": 1.0, "references": [], "created_at": "2026-02-11T01:16:33.494910"}
